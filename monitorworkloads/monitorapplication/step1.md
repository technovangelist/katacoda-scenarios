We have updated the configuration of all the components of our app to be in line with what we did in the previous lab. So let's just do a quick review of that. And then we will update the Real User Monitoring ID's to ensure that data is showing up in our account correctly. 

1.  Now lets take a look at what is in the config files. In the IDE tab, navigate to **deploy/datadog** and open **helm-values.yaml**. This is the values file for the Datadog Helm chart.
2.  You can see around line 204, logs are enabled and we have **containerCollectAll** set to **true**. These means that all the logs that Kubernetes knows about are going to be collected. Below, you will see how we can also collect file-based logs. 
3.  The Kubernetes cluster we have is not meant for production use. For one thing, there are no SSL certs in place. So we have had to override the autodiscovery configuration for etcd on the controlplane node. You can see that at line 265.
4.  We want this one Helm chart to install the Agent to both the worker nodes as well as the controlplane, but if you run `k describe node controlplane`{{execute}}, you will see near the top that there is a taint. So at line 1060 we specify a toleration to ensure that the Agent will be scheduled on the controlplane. There are no taints on the nodes, so we only need the single toleration.
5.  Now navigate to **deploy/generic-k8s/ecommerce-app**. You should see 4 YAML files there for **advertisements**, **db**, **discounts**, and **frontend**.
6.  Open the **advertisements.yaml** file in the editor.
7.  First notice that we have labels set at **metadata** and **spec.template.metadata**. Scroll down to **spec.template.spec.containers.env**. You can see a number of environment variables here, including: `DATADOG_SERVICE_NAME`, `DD_ENV`, `DD_AGENT_HOST`, `DD_LOGS_INJECTION`, `DD_ANALYTICS_ENABLED`, and `DD_PROFILING_ENABLED` . These environment variables are all that is needed to enable different features like profiling, and more. 
8.  You should see similar values set in **discounts.yaml**
9.  **db.yaml** has a few changes. First notice the two configmaps. These are setting the datadog user in postgres, as well as giving access to the database monitoring features. Further down you will see the labels and annotations set. 
10. If our application also generated file-based logs we could set the logs annotation value to be more like: `'[{"type":"file", "source": "webapp", "service": "backend-prod", "path": "/logs/app/prod.log"}]'`
11. In **frontend.yaml** you will need to update the settings for RUM. In Datadog, navigate to **UX Monitoring | RUM Applications** and click on the application you configured in the previous lab. Take note of the **ApplicationID** and the **ClientToken** and update the yaml file accordingly. 
12. Now run `k apply -f deploy/generic-k8s/ecommerce-app/frontend.yaml`{{execute}} to restart the Frontend. 
13. Open the StoreDog app and start looking around the app so that we have some data in Datadog. (Note: if you use a DNS-based ad blocking service like Pi-Hole, you will need to either temporarily disable the service, or add datadoghq-browser-agent.com to your Whitelist as a wildcard domain.)
